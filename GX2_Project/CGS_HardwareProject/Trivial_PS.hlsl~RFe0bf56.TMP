struct OUTPUT_VERTEX
{
	float4 projectedCoordinate : SV_POSITION;
	float3 normal : NORMAL;
	float2 texOut : TEXCOORD0;
	float4 worldPos : POSITION;
};

texture2D baseTexture : register(t0);

SamplerState baseFilter : register(s0);

cbuffer THIS_IS_VRAM : register(b0)
{
	float4x4 worldMatrix;
	float4x4 viewMatrix;
	float4x4 projectionMatrix;

	float3 lightDirection;
	//float4 lightPosition
	float4 ambientColor;
}

float4 main(OUTPUT_VERTEX vertex ) : SV_TARGET
{
	float3 lightDir;
	float lightIntensity;
	float4 color;
	
	float4 ambient;

	color = baseTexture.Sample(baseFilter, vertex.texOut);

	lightDir = -normalize(lightDirection);
	
	ambient = color * float4(0.3f, 0.3f, 0.3f, 1.0f);

	// for point light
	//lightDirWithPos = normalize(lightPosition - float3(vertex.worldPos.x, vertex.worldPos.y, vertex.worldPos.z));
	//float lightRatio = saturate(dot(lightDirWithPos, vertex.normal));
	//color += lightRatio * ambientColor;

	//for spot light
	//lightDirWithPos = normalize(lightPosition = float3(vertex.worldPos.x, vertex.worldPos.y, vertex.worldPos.z));
	//float surfaceRatio = saturate(dot(-lightDirWithPos, coneDir));
	//float spotFactor = (surfaceRatio > coneRatio) ? 1 : 0;
	//float lightRatio = saturate(dot(lightDirWithPos, vertex.normal));
	//color += spotFactor * lightRatio * ambientColor;

	lightIntensity = saturate(dot(lightDir, vertex.normal));
	//lightIntensity = saturate(lightIntensity + ambient);
	
	//if (lightIntensity > 0.0f)
	//{
		color = lightIntensity * ambient * color;
	//}
	
	color = saturate(color);

	return color;
}